/*
 * Copyright (C) 2007 Free Software Foundation, Inc.
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *
 *   This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 *
 *   0. Additional Definitions.
 *
 *   As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 *
 *   "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 *
 *   An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 *
 *   A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 *
 *   The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 *
 *   The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 *
 *   1. Exception to Section 3 of the GNU GPL.
 *
 *   You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 *
 *   2. Conveying Modified Versions.
 *
 *   If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 *
 *    a) under this License, provided that you make a good faith effort to
 *    ensure that, in the event an Application does not supply the
 *    function or data, the facility still operates, and performs
 *    whatever part of its purpose remains meaningful, or
 *
 *    b) under the GNU GPL, with none of the additional permissions of
 *    this License applicable to that copy.
 *
 *   3. Object Code Incorporating Material from Library Header Files.
 *
 *   The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 *
 *    a) Give prominent notice with each copy of the object code that the
 *    Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the object code with a copy of the GNU GPL and this license
 *    document.
 *
 *   4. Combined Works.
 *
 *   You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 *
 *    a) Give prominent notice with each copy of the Combined Work that
 *    the Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *    document.
 *
 *    c) For a Combined Work that displays copyright notices during
 *    execution, include the copyright notice for the Library among
 *    these notices, as well as a reference directing the user to the
 *    copies of the GNU GPL and this license document.
 *
 *    d) Do one of the following:
 *
 *        0) Convey the Minimal Corresponding Source under the terms of this
 *        License, and the Corresponding Application Code in a form
 *        suitable for, and under terms that permit, the user to
 *        recombine or relink the Application with a modified version of
 *        the Linked Version to produce a modified Combined Work, in the
 *        manner specified by section 6 of the GNU GPL for conveying
 *        Corresponding Source.
 *
 *        1) Use a suitable shared library mechanism for linking with the
 *        Library.  A suitable mechanism is one that (a) uses at run time
 *        a copy of the Library already present on the user's computer
 *        system, and (b) will operate properly with a modified version
 *        of the Library that is interface-compatible with the Linked
 *        Version.
 *
 *    e) Provide Installation Information, but only if you would otherwise
 *    be required to provide such information under section 6 of the
 *    GNU GPL, and only to the extent that such information is
 *    necessary to install and execute a modified version of the
 *    Combined Work produced by recombining or relinking the
 *    Application with a modified version of the Linked Version. (If
 *    you use option 4d0, the Installation Information must accompany
 *    the Minimal Corresponding Source and Corresponding Application
 *    Code. If you use option 4d1, you must provide the Installation
 *    Information in the manner specified by section 6 of the GNU GPL
 *    for conveying Corresponding Source.)
 *
 *   5. Combined Libraries.
 *
 *   You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 *
 *    a) Accompany the combined library with a copy of the same work based
 *    on the Library, uncombined with any other library facilities,
 *    conveyed under the terms of this License.
 *
 *    b) Give prominent notice with the combined library that part of it
 *    is a work based on the Library, and explaining where to find the
 *    accompanying uncombined form of the same work.
 *
 *   6. Revised Versions of the GNU Lesser General Public License.
 *
 *   The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.
 *
 *   Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 *
 *   If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */

package com.videoedit.trimvideo;

import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.content.Context;
import android.content.Intent;
import android.graphics.SurfaceTexture;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.Surface;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.animation.Animation;
import android.view.animation.LinearInterpolator;
import android.view.animation.TranslateAnimation;
import android.widget.FrameLayout;
import android.widget.FrameLayout.LayoutParams;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.bumptech.glide.Glide;
import com.temp.videoedit.R;
import com.videoedit.MyApplication;
import com.videoedit.VideoFilterConfig;
import com.videoedit.composer.Mp4Composer;
import com.videoedit.effect.FillMode;
import com.videoedit.effect.GlVideoView;
import com.videoedit.effect.helper.MagicFilterFactory;
import com.videoedit.effect.helper.MagicFilterType;
import com.videoedit.pickvideo.BaseActivity;
import com.videoedit.selcover.SelCoverTimeActivity;
import com.videoedit.utils.ConfigUtils;
import com.videoedit.utils.ExtractFrameWorkThread;
import com.videoedit.utils.ExtractVideoInfoUtil;
import com.videoedit.utils.UIUtils;
import com.videoedit.utils.VideoUtil;
import com.videoedit.view.FilterModel;
import com.videoedit.view.NormalProgressDialog;
import com.videoedit.view.RangeSeekBar;
import com.videoedit.view.VideoEditInfo;
import com.videoedit.view.VideoThumbSpacingItemDecoration;

import java.lang.ref.WeakReference;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import butterknife.BindView;
import butterknife.ButterKnife;
import butterknife.OnClick;
import io.reactivex.Observable;
import io.reactivex.ObservableEmitter;
import io.reactivex.ObservableOnSubscribe;
import io.reactivex.Observer;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.disposables.Disposable;
import io.reactivex.schedulers.Schedulers;

public class TrimVideoActivity extends BaseActivity  {

    @BindView(R.id.glsurfaceview)
    GlVideoView mSurfaceView;
    @BindView(R.id.video_shoot_tip)
    TextView mTvShootTip;
    @BindView(R.id.video_thumb_listview)
    RecyclerView mRecyclerView;
    @BindView(R.id.positionIcon)
    ImageView mIvPosition;
    @BindView(R.id.id_seekBarLayout)
    LinearLayout seekBarLayout;
    @BindView(R.id.layout_surface_view)
    RelativeLayout mRlVideo;
    @BindView(R.id.view_trim_indicator)
    View mViewTrimIndicator;
    @BindView(R.id.view_effect_indicator)
    View mViewEffectIndicator;
    @BindView(R.id.ll_trim_container)
    LinearLayout mLlTrimContainer;
    @BindView(R.id.ll_effect_container)
    LinearLayout mLlEffectContainer;
    @BindView(R.id.local_video_next_tv)
    TextView mNextVideoNext;
    @BindView(R.id.bottom_controller)
    RelativeLayout mBottomController;
    @BindView(R.id.local_title)
    RelativeLayout mLocalTitle;
    @BindView(R.id.second_mode_title)
    RelativeLayout mSecondModeTitle;


    private RangeSeekBar seekBar;

    @BindView(R.id.bottom_bar)
            LinearLayout mBottomBar;

    private int mVideoViewInitHeight = 0;

    interface MODE_FILTER{
        int MODE_NORMAL = 1001;
        int MODE_SPLIT = 1002;
    }

    private int mCurrentSplitMode = MODE_FILTER.MODE_NORMAL;

    //这个是相对于自身往上平移自身高度的动画
    TranslateAnimation translateAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,
            Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,-1.0f);
    //这个是相对于自身往下平移自身高度的动画

    TranslateAnimation translateAnimation1 = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f,
            Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,
            0.0f, Animation.RELATIVE_TO_SELF, 1.0f);

    private static final String TAG = TrimVideoActivity.class.getSimpleName();
    private static final long MIN_CUT_DURATION = VideoFilterConfig.VIDEO_CAPTURE_LENGTH_MIN * 1000L;// 最小剪辑时间3s
    private static final long MAX_CUT_DURATION = VideoFilterConfig.VIDEO_CAPTURE_LENGTH_MAX * 1000L;//视频最多剪切多长时间
    private static final int MAX_COUNT_RANGE = 10;//seekBar的区域内一共有多少张图片
    private static final int MARGIN = UIUtils.dp2Px(56); //左右两边间距
    private ExtractVideoInfoUtil mExtractVideoInfoUtil;
    private int mMaxWidth; //可裁剪区域的最大宽度
    private long duration; //视频总时长
    private TrimVideoAdapter videoEditAdapter;
    private float averageMsPx;//每毫秒所占的px
    private float averagePxMs;//每px所占用的ms毫秒
    private String OutPutFileDirPath;
    private int mInitRotation;//视频初始旋转角度，竖屏为90，横屏为0
    private ExtractFrameWorkThread mExtractFrameWorkThread;
    private long leftProgress, rightProgress; //裁剪视频左边区域的时间位置, 右边时间位置
    private long scrollPos = 0;
    private int mScaledTouchSlop;
    private int lastScrollX;
    private boolean isSeeking;
    private String mVideoPath;
    private List<FilterModel> mVideoEffects; //视频滤镜效果
    private List<FilterModel> mVideoEffectsNormal = new ArrayList<>(); //视频滤镜效果
    private List<FilterModel> mVideoEffectsSplit = new ArrayList<>(); //分屏滤镜效果
    private MagicFilterType[] mMagicFilterTypes;
    private MagicFilterType[] mMagicFilterTypesNormal;
    private MagicFilterType[] mMagicFilterTypesSplit;
    private ValueAnimator mEffectAnimator;
    private SurfaceTexture mSurfaceTexture;
    private MediaPlayer mMediaPlayer;
    private Mp4Composer mMp4Composer;
    private int rotate;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        init();
        setContentView( R.layout.activity_trim_video);
        ButterKnife.bind(this);

        initView();
        mInitRotation = getRotation();
    }

    @Override
    public void permissionGranted(){

    }

    public static void startActivity(Context context, String videoPath) {
        Intent intent = new Intent(context, TrimVideoActivity.class);
        intent.putExtra("videoPath", videoPath);
        context.startActivity(intent);
    }


    protected void init() {
        mVideoPath = getIntent().getStringExtra("videoPath");

        mExtractVideoInfoUtil = new ExtractVideoInfoUtil(mVideoPath);
        mMaxWidth = UIUtils.getScreenWidth() - MARGIN * 2;
        mScaledTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop();

        Observable.create(new ObservableOnSubscribe<String>() {
            @Override
            public void subscribe(ObservableEmitter<String> e) {
                e.onNext(mExtractVideoInfoUtil.getVideoLength());
                e.onComplete();
            }
        })
            .subscribeOn(Schedulers.newThread())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Observer<String>() {
                @Override
                public void onSubscribe(Disposable d) {
                   subscribe(d);
                }

                @Override
                public void onNext(String s) {
                    duration = Long.valueOf(mExtractVideoInfoUtil.getVideoLength());
                    //矫正获取到的视频时长不是整数问题
                    float tempDuration = duration / 1000f;
                    duration = new BigDecimal(tempDuration).setScale(0, BigDecimal.ROUND_HALF_DOWN).intValue() * 1000;
                    Log.e(TAG, "视频总时长：" + duration);
                    initEditVideo();
                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onComplete() {

                }
            });
    }

    protected void initView() {
        mRecyclerView
            .setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));
        videoEditAdapter = new TrimVideoAdapter(this, mMaxWidth / MAX_COUNT_RANGE);
        mRecyclerView.setAdapter(videoEditAdapter);
        if(android.os.Build.VERSION.SDK_INT>=26){
            mSurfaceView.setVisibility(View.INVISIBLE);
            mSurfaceView.setVisibility(View.VISIBLE);
        }
        mRecyclerView.addOnScrollListener(mOnScrollListener);
        mSurfaceView.setZOrderOnTop(true);
        mSurfaceView.setZOrderMediaOverlay(true);
//        mSurfaceView.getHolder().setFormat(PixelFormat.TRANSLUCENT);
        mSurfaceView.init(surfaceTexture -> {
            mSurfaceTexture = surfaceTexture;
            initMediaPlayer(mSurfaceTexture);
        });


        //滤镜效果集合
        mMagicFilterTypesNormal = new MagicFilterType[]{
            MagicFilterType.NONE, MagicFilterType.INVERT,
            MagicFilterType.SEPIA, MagicFilterType.BLACKANDWHITE,
            MagicFilterType.TEMPERATURE, MagicFilterType.OVERLAY,
                MagicFilterType.POSTERIZE,
            MagicFilterType.CONTRAST, MagicFilterType.GAMMA,
            MagicFilterType.HUE, MagicFilterType.CROSSPROCESS,
            MagicFilterType.GRAYSCALE,
        };

        for (int i = 0; i < mMagicFilterTypesNormal.length; i++) {
            FilterModel model = new FilterModel();
            model.setName(
                UIUtils.getString(MagicFilterFactory.filterType2Name(mMagicFilterTypesNormal[i])));
            mVideoEffectsNormal.add(model);
        }


        //滤镜效果集合
        mMagicFilterTypesSplit = new MagicFilterType[]{
                MagicFilterType.NONE,MagicFilterType.SPLIT_BLUR, MagicFilterType.SPLIT_BLUR_WHITE,
                MagicFilterType.SPLIT_2, MagicFilterType.SPLIT_3,
        };

        for (int i = 0; i < mMagicFilterTypesSplit.length; i++) {
            FilterModel model = new FilterModel();
            model.setName(
                    UIUtils.getString(MagicFilterFactory.filterType2Name(mMagicFilterTypesSplit[i])));
            mVideoEffectsSplit.add(model);
        }
        mMagicFilterTypes = mMagicFilterTypesNormal;
        mVideoEffects = mVideoEffectsNormal;

        addEffectView();
    }

    @OnClick({R.id.ll_trim_tab, R.id.ll_effect_tab, R.id.local_video_next_tv, R.id.local_back_iv, R.id.local_filter_iv, R.id.mode_cancel, R.id.mode_confirm, R.id.local_rotate_iv})
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.ll_effect_tab: //滤镜tab
                mViewTrimIndicator.setVisibility(View.GONE);
                mViewEffectIndicator.setVisibility(View.VISIBLE);
                mCurrentSplitMode = MODE_FILTER.MODE_NORMAL;
                mMagicFilterTypes = mMagicFilterTypesNormal;
                mVideoEffects = mVideoEffectsNormal;
                addEffectView();
                break;
            case R.id.ll_trim_tab: //分屏
            mViewTrimIndicator.setVisibility(View.VISIBLE);
            mViewEffectIndicator.setVisibility(View.GONE);
                mCurrentSplitMode = MODE_FILTER.MODE_SPLIT;
                mMagicFilterTypes = mMagicFilterTypesSplit;
                mVideoEffects = mVideoEffectsSplit;
                addEffectView();
            break;
            case R.id.local_video_next_tv:
                trimmerVideo();
                break;
            case R.id.local_back_iv:
                finish();
                break;
            case R.id.local_filter_iv:
                mBottomBar.startAnimation(translateAnimation);
                mBottomBar.setVisibility(View.VISIBLE);
                mBottomController.setVisibility(View.GONE);
                mLocalTitle.setVisibility(View.GONE);
                mSecondModeTitle.setVisibility(View.VISIBLE);
                break;
            case R.id.mode_cancel:
                ConfigUtils.getInstance().setMagicFilterType(mMagicFilterTypesNormal[0]);
                mSurfaceView.setFilter(MagicFilterFactory.getFilter());
            case R.id.mode_confirm:
                mBottomBar.startAnimation(translateAnimation1);
                mBottomBar.setVisibility(View.GONE);
                mBottomController.setVisibility(View.VISIBLE);
                mLocalTitle.setVisibility(View.VISIBLE);
                mSecondModeTitle.setVisibility(View.GONE);
                break;
            case R.id.local_rotate_iv:
                if (rotate < 270) {
                    rotate = rotate + 90;
                } else {
                    rotate = 0;
                }
                Log.d(TAG, "-------mInitRotation--->>>>" + mInitRotation);
                Log.d(TAG, "-------rotate--->>>>" + rotate);
                int rotation = mInitRotation + rotate;
                if(rotate == 90 || rotate == 270){
                    setLandScapeParam();
                }else{
                    setPortraitParam();
                }
//                mLocalVideoView.setRotation(rotation);
               /* ObjectAnimator animator = ObjectAnimator.ofFloat(mLocalVideoView, "rotation", mRotate, rotation);
                animator.setDuration(500);
                animator.start();*/
                if (mInitRotation == 90) {
                    if (rotation > 270) {
                        rotation = 0;
                    }
                    mSurfaceView.getVideoGlRender().setRotation(rotation);
                } else {
                    mSurfaceView.getVideoGlRender().setRotation(rotate);
                }
                break;
        }
    }


    @NonNull
    private void setPortraitParam() {
        ViewGroup.LayoutParams layoutParams1 = mSurfaceView.getLayoutParams();
        layoutParams1.height = mVideoViewInitHeight;
        layoutParams1.width = (int)(mVideoViewInitHeight * getWHRate());
        mSurfaceView.setLayoutParams(layoutParams1);
        mSurfaceView.requestLayout();
    }
    @NonNull
    private void setLandScapeParam() {
        ViewGroup.LayoutParams layoutParams1 = mSurfaceView.getLayoutParams();
        layoutParams1.width = MyApplication.screenWidth;
        Log.d(TAG, "MyApplication.screenWidth --->" + MyApplication.screenWidth );
        Log.d(TAG, "mExtractVideoInfoUtil.getVideoWidth()--->" + mExtractVideoInfoUtil.getVideoWidth());
        Log.d(TAG, "mExtractVideoInfoUtil.getVideoHeight()--->" + mExtractVideoInfoUtil.getVideoHeight());
        layoutParams1.height = (int)(MyApplication.screenWidth * getWHRate());
        mSurfaceView.setLayoutParams(layoutParams1);
        mSurfaceView.requestLayout();
    }

    /**
     * 小数
     * @return
     */
    private float mVideoRate = 0f;
    private float getWHRate(){
        if(mVideoRate == 0f){
            int width = mExtractVideoInfoUtil.getVideoWidth();
            int height = mExtractVideoInfoUtil.getVideoHeight();
            if(width > height){
                mVideoRate = height/(float)width;
            }else{
                mVideoRate = width/(float)height;
            }
        }

        return mVideoRate;
    }

    /**
     * 动态添加滤镜效果View
     */
    private void addEffectView() {
        mLlEffectContainer.removeAllViews();
        for (int i = 0; i < mVideoEffects.size(); i++) {
            View itemView = LayoutInflater.from(this)
                .inflate(R.layout.item_video_effect, mLlEffectContainer, false);
            TextView tv = itemView.findViewById(R.id.tv);
            ImageView iv = itemView.findViewById(R.id.iv);
            FilterModel model = mVideoEffects.get(i);
            int thumbId = MagicFilterFactory.filterType2Thumb(mMagicFilterTypes[i]);
            Glide.with(MyApplication.getContext())
                .load(thumbId)
                .into(iv);
            tv.setText(model.getName());
            int index = i;
            itemView.setOnClickListener(v -> {
                for (int j = 0; j < mLlEffectContainer.getChildCount(); j++) {
                    View tempItemView = mLlEffectContainer.getChildAt(j);
                    TextView tempTv = tempItemView.findViewById(R.id.tv);
                    FilterModel tempModel = mVideoEffects.get(j);
                    if (j == index) {
                        //选中的滤镜效果
                        if (!tempModel.isChecked()) {
                            openEffectAnimation(tempTv, tempModel, true);
                        }
                        ConfigUtils.getInstance().setMagicFilterType(mMagicFilterTypes[j]);
                        mSurfaceView.setFilter(MagicFilterFactory.getFilter());
                    } else {
                        //未选中的滤镜效果
                        if (tempModel.isChecked()) {
                            openEffectAnimation(tempTv, tempModel, false);
                        }
                    }
                }
            });
            mLlEffectContainer.addView(itemView);
        }
    }

    private void openEffectAnimation(TextView tv, FilterModel model, boolean isExpand) {
        model.setChecked(isExpand);
        int startValue = UIUtils.dp2Px(30);
        int endValue = UIUtils.dp2Px(100);
        if (!isExpand) {
            startValue = UIUtils.dp2Px(100);
            endValue = UIUtils.dp2Px(30);
        }
        mEffectAnimator = ValueAnimator.ofInt(startValue, endValue);
        mEffectAnimator.setDuration(300);
        mEffectAnimator.addUpdateListener(new AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                int value = (Integer) animation.getAnimatedValue();
                FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
                    LayoutParams.MATCH_PARENT, value, Gravity.BOTTOM);
                tv.setLayoutParams(params);
                tv.requestLayout();
            }
        });
        mEffectAnimator.start();
    }

    private void initEditVideo() {
        //for video edit
        long startPosition = 0;
        long endPosition = duration;
        int thumbnailsCount;
        int rangeWidth;
        boolean isOver_180_s;
        if (endPosition <= MAX_CUT_DURATION) {
            isOver_180_s = false;
            thumbnailsCount = MAX_COUNT_RANGE;
            rangeWidth = mMaxWidth;
        } else {
            isOver_180_s = true;
            thumbnailsCount = (int) (endPosition * 1.0f / (MAX_CUT_DURATION * 1.0f)
                * MAX_COUNT_RANGE);
            rangeWidth = mMaxWidth / MAX_COUNT_RANGE * thumbnailsCount;
        }
        mRecyclerView
            .addItemDecoration(new VideoThumbSpacingItemDecoration(MARGIN, thumbnailsCount));

        //init seekBar
        if (isOver_180_s) {
            seekBar = new RangeSeekBar(this, 0L, MAX_CUT_DURATION);
            seekBar.setSelectedMinValue(0L);
            seekBar.setSelectedMaxValue(MAX_CUT_DURATION);
        } else {
            seekBar = new RangeSeekBar(this, 0L, endPosition);
            seekBar.setSelectedMinValue(0L);
            seekBar.setSelectedMaxValue(endPosition);
        }
        seekBar.setMin_cut_time(MIN_CUT_DURATION);//设置最小裁剪时间
        seekBar.setNotifyWhileDragging(true);
        seekBar.setOnRangeSeekBarChangeListener(mOnRangeSeekBarChangeListener);
        seekBarLayout.addView(seekBar);

        Log.d(TAG, "-------thumbnailsCount--->>>>" + thumbnailsCount);
        averageMsPx = duration * 1.0f / rangeWidth * 1.0f;
        Log.d(TAG, "-------rangeWidth--->>>>" + rangeWidth);
        Log.d(TAG, "-------localMedia.getDuration()--->>>>" + duration);
        Log.d(TAG, "-------averageMsPx--->>>>" + averageMsPx);
        OutPutFileDirPath = VideoUtil.getSaveEditThumbnailDir(this);
        int extractW = mMaxWidth / MAX_COUNT_RANGE;
        int extractH = UIUtils.dp2Px(62);
        mExtractFrameWorkThread = new ExtractFrameWorkThread(extractW, extractH, mUIHandler,
            mVideoPath,
            OutPutFileDirPath, startPosition, endPosition, thumbnailsCount);
        mExtractFrameWorkThread.start();

        //init pos icon start
        leftProgress = 0;
        if (isOver_180_s) {
            rightProgress = MAX_CUT_DURATION;
        } else {
            rightProgress = endPosition;
        }
        mTvShootTip.setText(String.format("裁剪 %d s", rightProgress / 1000));
        averagePxMs = (mMaxWidth * 1.0f / (rightProgress - leftProgress));
        Log.d(TAG, "------averagePxMs----:>>>>>" + averagePxMs);
    }

    private int getRotation() {
        try {
            MediaExtractor extractor = new MediaExtractor();
            extractor.setDataSource(mVideoPath);
            int count = extractor.getTrackCount();
            for (int m = 0; m < count; m++) {
                MediaFormat format = extractor.getTrackFormat(m);
                String mime = format.getString(MediaFormat.KEY_MIME);
                if (mime.contains("video")) {
                    System.out.println("cdw format = "+format);
                    return format.getInteger(MediaFormat.KEY_ROTATION);
                }
            }
        } catch (Throwable throwable) {
            System.out.println("cdw error "+Log.getStackTraceString(throwable));
            return 0;
        }
        return 0;
    }


    Surface surface;
    /**
     * 初始化MediaPlayer
     */
    private void initMediaPlayer(SurfaceTexture surfaceTexture) {
        mSurfaceView.getVideoGlRender().setRotation(getRotation());
        mMediaPlayer = new MediaPlayer();
//        mMediaPlayer.setOnErrorListener(this);
        try {
            mMediaPlayer.setDataSource(mVideoPath);
            surface = new Surface(surfaceTexture);
            mMediaPlayer.setSurface(surface);
//            surface.release();
//            mMediaPlayer.setLooping(true);
            mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
                @Override
                public void onPrepared(MediaPlayer mp) {
                    ViewGroup.LayoutParams lp = mSurfaceView.getLayoutParams();
                    int videoWidth = mp.getVideoWidth();
                    int videoHeight = mp.getVideoHeight();
                    float videoProportion = (float) videoWidth / (float) videoHeight;
                    int screenWidth = mRlVideo.getWidth();
                    int screenHeight = mRlVideo.getHeight();
                    float screenProportion = (float) screenWidth / (float) screenHeight;
                    if (videoProportion > screenProportion) {
                        lp.width = screenWidth;
                        lp.height = (int) ((float) screenWidth / videoProportion);
                    } else {
                        lp.width = (int) (videoProportion * (float) screenHeight);
                        lp.height = screenHeight;
                    }
                    mSurfaceView.setLayoutParams(lp);

                    Log.e("videoView", "videoWidth:" + videoWidth + ", videoHeight:" + videoHeight);

                    //设置MediaPlayer的OnSeekComplete监听
                    mp.setOnSeekCompleteListener(new MediaPlayer.OnSeekCompleteListener() {
                        @Override
                        public void onSeekComplete(MediaPlayer mp) {
                            Log.d(TAG, "------ok----real---start-----");
                            Log.d(TAG, "------isSeeking-----" + isSeeking);
                            if (!isSeeking) {
                                videoStart();
                            }
                        }
                    });
                }
            });
            mMediaPlayer.prepare();
            videoStart();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 视频裁剪
     */
    private void trimmerVideo() {
        NormalProgressDialog
                .showLoading(this, getResources().getString(R.string.in_process), false);
        videoPause();
        Log.e(TAG, "trimVideo...startSecond:" + leftProgress + ", endSecond:"
                + rightProgress); //start:44228, end:48217
        //裁剪后的小视频第一帧图片
        // /storage/emulated/0/haodiaoyu/small_video/picture_1524055390067.jpg
//        Bitmap bitmap = mExtractVideoInfoUtil.extractFrame(leftProgress);
//        String firstFrame = FileUtil.saveBitmap("small_video", bitmap);
//        if (bitmap != null && !bitmap.isRecycled()) {
//            bitmap.recycle();
//            bitmap = null;
//        }
        VideoUtil
                .cutVideo(mVideoPath, VideoUtil.getTrimmedVideoPath(this, VideoFilterConfig.VIDEO_CACHE_FILE_DIR,
                        "trimmedVideo_"), leftProgress / 1000,
                        rightProgress / 1000)
                .subscribe(new Observer<String>() {
                    @Override
                    public void onSubscribe(Disposable d) {
                        subscribe(d);
                    }

                    @Override
                    public void onNext(String outputPath) {
                        Log.e(TAG, "cutVideo---onSuccess");
                        try {
                            startMediaCodec(outputPath);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }

                    @Override
                    public void onError(Throwable e) {
                        e.printStackTrace();
                        Log.e(TAG, "cutVideo---onError:" + e.toString());
                        NormalProgressDialog.stopLoading();
                        Toast.makeText(TrimVideoActivity.this, "视频裁剪失败", Toast.LENGTH_SHORT).show();
                    }

                    @Override
                    public void onComplete() {
                    }
                });
    }

    private boolean getFlipHorizontal(int initrotation, int rotation){
        if(initrotation == 90){
            switch (rotation){
                case 0:
                case 180:
                    return true;
                    default:
                        return false;
            }
        }else{
            switch (rotation){
                case 0:
                case 180:
                    return false;
                default:
                    return true;
            }
        }
    }

    private boolean getFlipVertial(int initrotation, int rotation){
        if(initrotation == 90){
            switch (rotation){
                case 0:
                case 180:
                    return false;
                default:
                    return true;
            }
        }else{
            switch (rotation){
                case 0:
                case 180:
                    return true;
                default:
                    return false;
            }
        }
    }

    /**
     * 视频添加滤镜效果
     */
    private void startMediaCodec(String srcPath) {
        final String outputPath = VideoUtil.getTrimmedVideoPath(this, VideoFilterConfig.VIDEO_CACHE_FILE_DIR,
                "filterVideo_");
        int genWidth;
        int genHeight;
        int finalRotate = rotate + mInitRotation;
        if(finalRotate == 0 || finalRotate == 180){
            genWidth = mExtractVideoInfoUtil.getVideoWidth();
            genHeight = mExtractVideoInfoUtil.getVideoHeight();
        }else{
            genWidth = mExtractVideoInfoUtil.getVideoHeight();
            genHeight = mExtractVideoInfoUtil.getVideoWidth();
        }




        mMp4Composer = new Mp4Composer(srcPath, outputPath)

                .fillMode(FillMode.CUSTOM)
//                .rotation(Rotation.fromInt(mInitRotation))
                .filter(MagicFilterFactory.getFilter().setRotation(finalRotate))//视频旋转后滤镜不旋转了（预览旋转滤镜）
                .size(genWidth, genHeight)
                .mute(false)
                .flipHorizontal(getFlipHorizontal(mInitRotation, rotate))
                .flipVertical(getFlipVertial(mInitRotation, rotate))
                .listener(new Mp4Composer.Listener() {
                    @Override
                    public void onProgress(double progress) {
                        Log.d(TAG, "filterVideo---onProgress: " + (int) (progress * 100));
                        runOnUiThread(() -> {
                            //show progress
                        });
                    }

                    @Override
                    public void onCompleted() {
                        Log.d(TAG, "filterVideo---onCompleted");
                        NormalProgressDialog.stopLoading();
                        runOnUiThread(() -> {
                            SelCoverTimeActivity.launch(TrimVideoActivity.this,outputPath);
//                            finish();
//                            compressVideo(outputPath);
                        });
                    }

                    @Override
                    public void onCanceled() {
                        NormalProgressDialog.stopLoading();
                    }

                    @Override
                    public void onFailed(Exception exception) {
                        Log.e(TAG, "filterVideo---onFailed()");
                        NormalProgressDialog.stopLoading();
//                        Toast.makeText(TrimVideoActivity.this, "视频处理失败", Toast.LENGTH_SHORT).show();
                    }
                })
                .start();
    }

    private final RecyclerView.OnScrollListener mOnScrollListener = new RecyclerView.OnScrollListener() {
        @Override
        public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
            super.onScrollStateChanged(recyclerView, newState);
            Log.d(TAG, "-------newState:>>>>>" + newState);
            if (newState == RecyclerView.SCROLL_STATE_IDLE) {
                isSeeking = false;
//                if (isOverScaledTouchSlop) {
//                    videoStart();
//                }
            } else {
                isSeeking = true;
//                if (isOverScaledTouchSlop) {
//                    videoPause();
//                }
            }
        }

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            super.onScrolled(recyclerView, dx, dy);
            isSeeking = false;
            int scrollX = getScrollXDistance();
            //达不到滑动的距离
//            if (Math.abs(lastScrollX - scrollX) < mScaledTouchSlop) {
//                isOverScaledTouchSlop = false;
//                return;
//            }
//            isOverScaledTouchSlop = true;
            Log.d(TAG, "-------scrollX:>>>>>" + scrollX);
            //初始状态,why ? 因为默认的时候有56dp的空白！
            if (scrollX == -MARGIN) {
                scrollPos = 0;
            } else {
                // why 在这里处理一下,因为onScrollStateChanged早于onScrolled回调
//                videoPause();
                isSeeking = true;
                scrollPos = (long) (averageMsPx * (MARGIN + scrollX));
                Log.d(TAG, "-------scrollPos:>>>>>" + scrollPos);
                leftProgress = seekBar.getSelectedMinValue() + scrollPos;
                rightProgress = seekBar.getSelectedMaxValue() + scrollPos;
                Log.d(TAG, "-------leftProgress:>>>>>" + leftProgress);
                mMediaPlayer.seekTo((int) leftProgress);
            }
            lastScrollX = scrollX;
        }
    };

    /**
     * 水平滑动了多少px
     *
     * @return int px
     */
    private int getScrollXDistance() {
        LinearLayoutManager layoutManager = (LinearLayoutManager) mRecyclerView.getLayoutManager();
        int position = layoutManager.findFirstVisibleItemPosition();
        View firstVisibleChildView = layoutManager.findViewByPosition(position);
        int itemWidth = firstVisibleChildView.getWidth();
        return (position) * itemWidth - firstVisibleChildView.getLeft();
    }

    private ValueAnimator animator;

    private void anim() {
//        Log.d(TAG, "--anim--onProgressUpdate---->>>>>>>" + mMediaPlayer.getCurrentPosition());
        if (mIvPosition.getVisibility() == View.GONE) {
            mIvPosition.setVisibility(View.VISIBLE);
        }
        final FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) mIvPosition
            .getLayoutParams();
        int start = (int) (MARGIN
            + (leftProgress/*mVideoView.getCurrentPosition()*/ - scrollPos) * averagePxMs);
        int end = (int) (MARGIN + (rightProgress - scrollPos) * averagePxMs);
        animator = ValueAnimator
            .ofInt(start, end)
            .setDuration(
                (rightProgress - scrollPos) - (leftProgress/*mVideoView.getCurrentPosition()*/
                    - scrollPos));
        animator.setInterpolator(new LinearInterpolator());
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                params.leftMargin = (int) animation.getAnimatedValue();
                mIvPosition.setLayoutParams(params);
            }
        });
        animator.start();
    }

    private final MainHandler mUIHandler = new MainHandler(this);

    private static class MainHandler extends Handler {

        private final WeakReference<TrimVideoActivity> mActivity;

        MainHandler(TrimVideoActivity activity) {
            mActivity = new WeakReference<>(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            TrimVideoActivity activity = mActivity.get();
            if (activity != null) {
                if (msg.what == ExtractFrameWorkThread.MSG_SAVE_SUCCESS) {
                    if (activity.videoEditAdapter != null) {
                        VideoEditInfo info = (VideoEditInfo) msg.obj;
                        activity.videoEditAdapter.addItemVideoInfo(info);
                    }
                }
            }
        }
    }

    private final RangeSeekBar.OnRangeSeekBarChangeListener mOnRangeSeekBarChangeListener = new RangeSeekBar.OnRangeSeekBarChangeListener() {
        @Override
        public void onRangeSeekBarValuesChanged(RangeSeekBar bar, long minValue, long maxValue,
            int action, boolean isMin, RangeSeekBar.Thumb pressedThumb) {
            Log.d(TAG, "-----minValue----->>>>>>" + minValue);
            Log.d(TAG, "-----maxValue----->>>>>>" + maxValue);
            leftProgress = minValue + scrollPos;
            rightProgress = maxValue + scrollPos;
            Log.d(TAG, "-----leftProgress----->>>>>>" + leftProgress);
            Log.d(TAG, "-----rightProgress----->>>>>>" + rightProgress);
            switch (action) {
                case MotionEvent.ACTION_DOWN:
                    Log.d(TAG, "-----ACTION_DOWN---->>>>>>");
                    isSeeking = false;
//                    videoPause();
                    break;
                case MotionEvent.ACTION_MOVE:
                    Log.d(TAG, "-----ACTION_MOVE---->>>>>>");
                    isSeeking = true;
                    mMediaPlayer.seekTo((int) (pressedThumb == RangeSeekBar.Thumb.MIN ?
                        leftProgress : rightProgress));
                    break;
                case MotionEvent.ACTION_UP:
                    Log.d(TAG, "-----ACTION_UP--leftProgress--->>>>>>" + leftProgress);
                    isSeeking = false;
                    //从minValue开始播
                    mMediaPlayer.seekTo((int) leftProgress);
//                    videoStart();
                    mTvShootTip
                        .setText(String.format("裁剪 %d s", (rightProgress - leftProgress) / 1000));
                    break;
                default:
                    break;
            }
        }
    };

    private void videoStart() {
        Log.d(TAG, "----videoStart----->>>>>>>");
        mMediaPlayer.start();
        mIvPosition.clearAnimation();
        if (animator != null && animator.isRunning()) {
            animator.cancel();
        }
        anim();
        handler.removeCallbacks(run);
        handler.post(run);
    }

    private void videoProgressUpdate() {
        mSurfaceView.setZOrderOnTop(true);
        mSurfaceView.setZOrderMediaOverlay(true);
        mRlVideo.bringChildToFront(mSurfaceView);
        long currentPosition = mMediaPlayer.getCurrentPosition();
            if (currentPosition >= (rightProgress - 500)) {
                mMediaPlayer.seekTo((int) leftProgress);
                mIvPosition.clearAnimation();
                if (animator != null && animator.isRunning()) {
                    animator.cancel();
                }
                anim();
            }
    }


    private void videoPause() {
        isSeeking = false;
        if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
            mMediaPlayer.pause();
            handler.removeCallbacks(run);
        }
        Log.d(TAG, "----videoPause----->>>>>>>");
        if (mIvPosition.getVisibility() == View.VISIBLE) {
            mIvPosition.setVisibility(View.GONE);
        }
        mIvPosition.clearAnimation();
        if (animator != null && animator.isRunning()) {
            animator.cancel();
        }
    }


    @Override
    protected void onResume() {
        super.onResume();
        if (mMediaPlayer != null) {
            mMediaPlayer.seekTo((int) leftProgress);
//            videoStart();
        }
        mSurfaceView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                int valueOne = mSurfaceView.getWidth();
                int valueTwo = mSurfaceView.getHeight();


                mVideoViewInitHeight = valueOne > valueTwo ? valueOne:valueTwo;
                mSurfaceView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            }
        });

    }


    private Handler handler = new Handler();
    private Runnable run = new Runnable() {

        @Override
        public void run() {
            videoProgressUpdate();
            handler.postDelayed(run, 100);
        }
    };

    @Override
    protected void onDestroy() {
        videoPause();
        NormalProgressDialog.stopLoading();
        ConfigUtils.getInstance().setMagicFilterType(MagicFilterType.NONE);
        if (animator != null) {
            animator.cancel();
        }
        if (mEffectAnimator != null) {
            mEffectAnimator.cancel();
        }
        if (mMediaPlayer != null) {
            mMediaPlayer.release();
        }
        if (mMp4Composer != null) {
            mMp4Composer.cancel();
        }
        if (mExtractVideoInfoUtil != null) {
            mExtractVideoInfoUtil.release();
        }
        if (mExtractFrameWorkThread != null) {
            mExtractFrameWorkThread.stopExtract();
        }
        mRecyclerView.removeOnScrollListener(mOnScrollListener);
        mUIHandler.removeCallbacksAndMessages(null);
        handler.removeCallbacksAndMessages(null);


        super.onDestroy();
    }
}
